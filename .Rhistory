habitat == 15 ~ "GM",
habitat == 16 ~ "SF",
habitat == 17 ~ "PP"
))
## -- create state_node_list of the management scenario
sem_int_edgelist_no_aggr<- rbind(sem_int_edgelist_rem,new_habitats_ab_rem)  #join new habitats and old habitats
#node_from
state_node_sem_int_from<- sem_int_edgelist_no_aggr %>% select(habitat,node_from,ab_node_from,
taxon_node_from) %>%
rename("node_id" ="node_from", "abundances" = "ab_node_from",
"taxon" = "taxon_node_from")%>%
group_by(habitat,node_id) %>% unique() #eliminate duplicate species within each habitat
#node_to
state_node_sem_int_to<- sem_int_edgelist_no_aggr %>% select(habitat,node_to,ab_node_to,
taxon_node_to) %>%
rename("node_id" ="node_to", "abundances" = "ab_node_to",
"taxon" = "taxon_node_to")%>%
group_by(habitat,node_id) %>% unique() #eliminate duplicate species within each habitat
state_node_sem_int_agg<-rbind(state_node_sem_int_from, state_node_sem_int_to) %>% ungroup() %>%
select(-habitat) %>% group_by(node_id) %>%
mutate(abun = sum(abundances)) %>% distinct(abun,taxon)
## --  Create edge list of new management scenario
sem_int_edgelist_aggr<-sem_int_edgelist_no_aggr %>% select(node_from,node_to) %>%
unique() %>%  #aggregated edge list
mutate(management = "SI")
int_edgelist_rem<- Norwood_farm$extended_ids %>%
filter(layer_from != 8 & layer_from != 10 &  layer_from != 4 &
layer_from != 5  &  layer_from != 2 &layer_from != 9 &
layer_from != 7& layer_from != 3 &  layer_from != 6 ) %>% #links from "WD", "RG", "MH", "NH","GM","SF", "PP", "LP","LU", and"NL removed
select(-layer_to) %>% rename("habitat" = "layer_from") %>%
left_join(state_nodes_ab, by = c("node_from" = "node_id",
"habitat" = "layer_id")) %>%  #incorporate abundances and taxa of node_from
left_join(state_nodes_ab, by = c("node_to" = "node_id",
"habitat" = "layer_id")) %>%  #incorporate abundances and taxa of nodes_to
rename("ab_node_from" = "abundance.x", "taxon_node_from" = "taxon.x",
"ab_node_to" = "abundance.y", "taxon_node_to" = "taxon.y")
int_edgelist_rem<-int_edgelist_rem[,c(1,2,5,4,3,7,6)]
# create habitats CP to replace LP,LU and NL (the rest were created before)
LP_CP<- Norwood_farm$extended_ids %>% filter(layer_from  == 1) %>% select(-layer_to,-layer_from) %>%
mutate (new_hab = 18, prev_hab = "LP", hab_cp = "CP")#links from "CP" to add as new habitat (19)
NL_CP<- Norwood_farm$extended_ids %>% filter(layer_from  == 1) %>% select(-layer_to,-layer_from) %>%
mutate (new_hab = 19, prev_hab = "NL", hab_cp = "CP")#links from "CP" to add as new habitat (21)
# calculate changes in the area between CP and the habitat to replace
converted_area<-rbind(WD_CP, RG_CP, MH_CP, NH_CP, GM_CP,SF_CP,PP_CP, LP_CP,NL_CP) %>%
left_join(habitat_area,   by = c("prev_hab" = "HabitatCode")) %>%
left_join(habitat_area, by = c("hab_cp" = "HabitatCode")) %>%
select(node_from,node_to,new_hab,prev_hab,hab_cp,area_ave.x,area_ave.y) %>%
rename("area_prev_hab" ="area_ave.x", "area_CP" = "area_ave.y") %>%
mutate(mult_ab = (area_prev_hab/area_CP)) %>% #multplied abundances of CP for this value (to estimate according to the new habitat)
select(-prev_hab,-hab_cp,-area_prev_hab,-area_CP)#clean dataframe
# add abundances and modify them according to the new area
abundances_CP<-state_nodes_ab %>% filter(layer_id ==1)#filter species abundances to show just layer CP
new_habitats_ab<-converted_area %>%
left_join(abundances_CP, by = c("node_from" = "node_id")) %>%  #incorporate abundances and taxa of node_from
left_join(abundances_CP, by = c("node_to" = "node_id")) %>%  #incorporate abundances and taxa of nodes_to
rename("ab_node_from_CP" = "abundance.x", "taxon_node_from" = "taxon.x",
"ab_node_to_CP" = "abundance.y", "taxon_node_to" = "taxon.y") %>%
mutate(ab_node_from = ab_node_from_CP * mult_ab,
ab_node_to = ab_node_to_CP * mult_ab ) %>% #estimate the new abundances
select(new_hab,node_from,ab_node_from,taxon_node_from,node_to,ab_node_to,
taxon_node_to) %>% rename ("habitat" = "new_hab") #clean to match the rest of farm edgelist
# remove interaction where one partner have less than 1 indidivual (threshold)
new_habitats_ab_rem<- new_habitats_ab %>% filter(ab_node_from >=1 & ab_node_to >=1)
#species in the new habitat
sp_LP_NL <- new_habitats_ab_rem %>%select(habitat,node_from,node_to) %>% group_by(habitat) %>%
gather("type","node_id",2:3) %>% select(habitat, node_id) %>% unique() %>%
mutate(habitat = case_when (
habitat == 18 ~ "LP",
habitat == 19 ~ "NL"
))
## -- create state_node_list of the management scenario
int_edgelist_no_aggr<- rbind(int_edgelist_rem,new_habitats_ab_rem)  #join new habitats and old habitats
#node_from
state_node_int_from<- int_edgelist_no_aggr %>% select(habitat,node_from,ab_node_from,
taxon_node_from) %>%
rename("node_id" ="node_from", "abundances" = "ab_node_from",
"taxon" = "taxon_node_from")%>%
group_by(habitat,node_id) %>% unique() #eliminate duplicate species within each habitat
#node_to
state_node_int_to<- int_edgelist_no_aggr %>% select(habitat,node_to,ab_node_to,
taxon_node_to) %>%
rename("node_id" ="node_to", "abundances" = "ab_node_to",
"taxon" = "taxon_node_to") %>%
group_by(habitat,node_id) %>% unique() #eliminate duplicate species within each habitat
# final state nodes (calculate abundance of species)
state_node_int_agg<-rbind(state_node_int_from, state_node_int_to) %>% ungroup() %>%
select(-habitat) %>% group_by(node_id) %>%
mutate(abun = sum(abundances)) %>% distinct(abun,taxon)
## --  Create edge list of new management scenario
int_edgelist_aggr<-int_edgelist_no_aggr %>% select(node_from,node_to) %>%
unique() %>%  #aggregated edge list
mutate(management = "I")
##### -- Intensive non-organic management (eliminate weeds from the network)
weeds = 1:93
crops = 94:99
aphid = 337:364
seed_ins = 476:494
seed_bird = 495:506
seed_rod = 507:510
herbivores <- c(aphid, seed_ins, seed_bird, seed_rod)
# Remove weeds from the intensive management
int_mon_edgelist_aggr<-int_edgelist_aggr %>%
filter(!(node_from%in%weeds), !(node_to%in%weeds)) %>%  #eliminate weeds and species that only interact with them
mutate(management = "IN")
# Remove herbivores that feed on weeds
# Step 1: Identify herbivores that interact with crops
interact_with_crops <- int_edgelist_aggr %>%
filter((node_from %in% herbivores & node_to %in% crops) |
(node_to %in% herbivores & node_from %in% crops)) %>%
select(node_from, node_to) %>%
unlist() %>%
as.numeric() %>%
unique()
herbivores_crops<-interact_with_crops[interact_with_crops > 99] #list of pest
# Step 2: Filter the dataset to include only interactions between herbivores and weeds, excluding those that interact with crops
interact_without_crops <- int_edgelist_aggr %>%
filter(
((node_from %in% herbivores & node_to %in% weeds) |
(node_to %in% herbivores & node_from %in% weeds)) &
!(node_from %in% herbivores_crops | node_to %in% herbivores_crops)
) %>%  select(node_from, node_to) %>%
unlist() %>%
as.numeric() %>%
unique()
herbivores_only_weeds<- interact_without_crops[interact_without_crops > 99] #list of herbivores that only interact with weeds
# Remove herbivores_only_weeds and their interactions in the dataframe
int_mon_edgelist_aggr2<-int_mon_edgelist_aggr %>%
filter(
!(node_from %in% herbivores_only_weeds) & !(node_to %in% herbivores_only_weeds))  # Exclude all interactions of herbivores only feed on weeds
# States nodes
state_node_int_mod_agg <- state_node_int_agg %>%
filter(node_id%in%int_mon_edgelist_aggr2$node_from |
node_id%in%int_mon_edgelist_aggr2$node_to)
##### ---  Final dataframe
land_change_weighted<-rbind(extensive_edgelist,sem_ext_edgelist_aggr,mod_edgelist_aggr,
sem_int_edgelist_aggr,int_edgelist_aggr,int_mon_edgelist_aggr2)
# final state_node list with abundances
state_nodes_weighted_ab<-rbind(ab_ext,state_node_sem_ext_agg,
state_node_mod_agg,state_node_sem_int_agg,
state_node_int_agg, state_node_int_mod_agg)
#add management label
state_nodes_weighted<-cbind(management = rep(c("E","SE","M","SI","I","IN"),
c(nrow(ab_ext),nrow(state_node_sem_ext_agg),
nrow(state_node_mod_agg), nrow(state_node_sem_int_agg),
nrow(state_node_int_agg), nrow(state_node_int_mod_agg))),
state_nodes_weighted_ab)
## Add information of ES to the nodes (values 0-1)
nodes_ES<- right_join(state_nodes_weighted, Norwood_farm$nodes, by = "node_id")%>%
select(management,node_id,taxon.x,abun, "Crop production",
"Pollination", "Crop damage", "Pest control", "Seed dispersal", "Butterfly watching", "Bird watching") %>%
group_by(management,node_id) %>% rename("taxon" = "taxon.x") %>%
gather("services","value", 5:11) #we conserve species that not directly provide ES because can serve as intermediate paths to ES-provider sps
nodes_ES$management <- factor(nodes_ES$management, levels = c("E", "SE", "M", "SI","I","IN")) #change order of factors
#upload file with body mass
body_mass<-read.csv("Data/biomass.csv",header=T)
# Calculate the amount of ES provided as the product between the abundance and biomass (for butterfly and watching we are using just the abundance)
direct_ES <- nodes_ES %>% filter (value ==1) %>%
left_join(body_mass,by = "node_id") %>% select(-node_name,-taxon.y) %>%
rename("taxon"="taxon.x", "body_mass" = "biomass.g") %>%
mutate (type = "D",
weight = abun * body_mass) %>% #amount of direct ES provision
select(-value)
list_nodes_ES_provi<-nodes_ES %>% ungroup() %>% select(-management,-abun) %>%
filter (value ==1) %>% unique # list of nodes that provide ES ( = no plants and ectoparasites)
list_nodes_ES_no_provi<-nodes_ES %>% ungroup() %>% select(-management,-abun,-services) %>% unique() %>%
group_by(node_id) %>% mutate(tot_serv = sum(value)) %>% select(-value) %>%
filter(tot_serv == 0) %>% mutate(services = "None", value = 1) %>% # filter species that not directly provide any ES and assign them as None
select(-tot_serv)
list_nodes_ES<-rbind(list_nodes_ES_provi,list_nodes_ES_no_provi) #Total list of nodes with ES (with None)
# Add attributes of nodes to the edgelist
edge_list<- left_join(land_change_weighted,list_nodes_ES, by = c("node_from"="node_id")) %>%
rename("taxon_from"="taxon", "services_from"="services",
"value_from" = "value") %>%
left_join(list_nodes_ES, by = c("node_to"="node_id"))  %>%
rename("taxon_to"="taxon", "services_to"="services",
"value_to" = "value")
# Add inverted links (to make the code easier to program when calculate indirect interactions. It will not affect the output)
edge_list_inverted<- tibble(values = edge_list$node_to,edge_list$node_from,
edge_list$management, edge_list$taxon_to,edge_list$services_to,
edge_list$value_to,  edge_list$taxon_from,edge_list$services_from,edge_list$value_from)
colnames(edge_list_inverted) <- c("node_from", "node_to", "management", "taxon_from", "services_from",
"value_from", "taxon_to", "services_to", "value_to")
# Combine both data frame to create the final edge list
edgelist_final<- bind_rows(edge_list, edge_list_inverted) %>%
select(-value_to,-value_from) # we are not using these anymore
edgelist_final<-edgelist_final[,c(3,1,4,5,2,6,7)]
# Create objects to store
management = c()
services_from = c()
node_from= c()
node_to = c()
taxon_from = c()
services_to = c()
# Reorder the dataframe to check indirect interaction in 1 hop
for (i in 1:nrow(edgelist_final)){
management = c(management, edgelist_final$management[i])
services_from = c(services_from,edgelist_final$services_from[i])
node_from = c(node_from,edgelist_final$node_from[i])
node_to = c(node_to,edgelist_final$node_to[i])
taxon_from = c(taxon_from, edgelist_final$taxon_from[i])
services_to = c(services_to, edgelist_final$services_to[i])
}
Indirect_1hop_landuse_weighted<-data.frame(management,services_from,node_from,node_to,taxon_from,
services_to,hop = rep(1, length(services_from)),
type = rep("I", length(services_from)))
rows_birds_butt<- Indirect_1hop_landuse_weighted %>%
filter(taxon_from == "Butterfly" | taxon_from == "Seed-feeding bird") %>%
distinct(management, node_from, node_to, .keep_all = TRUE) # new subset after eliminating duplicate rows for node_from = birds and butterflies
int_without<-Indirect_1hop_landuse_weighted %>% filter(!(taxon_from == "Butterfly" |
taxon_from == "Seed-feeding bird")) #eliminate the interactions containing node_from =birds or butterflies from the original dataframe
Indirect_1hop_landuse_weighted_2<-rbind(rows_birds_butt,int_without) #final dataframe containing indirect effects on ES via 1 hop
Indirect_1hop <-read.csv("Data/Land_use_ind_1hop.csv",
sep =",") #load dataframe of indirect effects using 1 hop
# Create empty vectors
management = c()
node_id= c()
node_int = c()
taxon_from = c()
services = c()
node_to = c()
services_to = c()
# Iterate to each row
for (i in 1:nrow(Indirect_1hop)){ #each row represents interaction between species
j = Indirect_1hop$node_to[i] # check the node_to from the 1 hop indirect effect (intermediate species: node 2 in the title)
l = Indirect_1hop$management [i] #check management where the target species for which we are detecting indirect effects on ES
# Filter dataframe (filter node 3's ES affected by node 2)
services_int <- Indirect_1hop %>% filter(node_from == j, #filter to show node 2
node_to != Indirect_1hop$node_from[i], #filter to avoid counting the interaction from node 2 to node 1 because the edgelist is directed
management== l) %>%
select(node_to,services_to)
# Storage the results
services_to <- c(services_to, unlist(services_int$services_to)) # add node 3 ES
node_to <- c(node_to, unlist(services_int$node_to))# add identity of node 3
node_int <- c(node_int,rep(j, nrow(services_int)))
node_id <- c(node_id,rep(Indirect_1hop$node_from[i], nrow(services_int)))# add target (node 1) for which we are detected indirect effects
taxon_from<- c(taxon_from, rep(Indirect_1hop$taxon_from[i], nrow(services_int)))
services <- c(services, rep (Indirect_1hop$services_from[i], nrow(services_int)))# direct ES provided by the target node
management <- c(management, rep(l, nrow(services_int)))
}
Indirect_2hop<- data.frame(management,node_id,taxon_from,services,node_int,
node_to, services_to,type = rep("I", length(services_to)), hop = rep(2,length(services_to)))
# 1 hop (node 1 - node 2)
Indirect_1hop_m<-Indirect_1hop  %>%  rename("services" ="services_from",
"node_id" = "node_from",
"taxon" = "taxon_from") %>%
mutate(node_int = NA)
Indirect_1hop_m<-Indirect_1hop_m[,c(1,2,3,5,9,4,6,7,8)]
# 2 hop (node 1 - node 2 - node 3)
Indirect_2hop_m<-Indirect_2hop %>% rename("taxon" = "taxon_from")
Indirect_2hop_m<-Indirect_2hop_m[,c(1,4,2,3,5,6,7,8,9)]
#  Total Indirect effect of ES
I_ES<- rbind(Indirect_1hop_m,Indirect_2hop_m)
I_ES2<- I_ES %>%  filter(services_to != 'None')
#upload and prepare dataframe
direct_ES<- read.csv("Data/Land_use_dir_ES.csv", sep =",")
direct_ES$management <- factor(direct_ES$management, levels = c("E", "SE", "M", "SI","I","IN")) #change order of factors
Prop_dir<-direct_ES %>% group_by(management,services) %>%
mutate(tot = n()) %>% ungroup() %>%
group_by(services) %>%
mutate(prop = tot/max(tot)) %>%  # Prop. of direct ES retained
dplyr::select(management,services,tot,prop) %>%
unique()
# adjust the extreme values according to the beta conditions
Prop_dir$prop <- ifelse(Prop_dir$prop == 0, 0.000001,
ifelse(Prop_dir$prop == 1, 0.9999999, Prop_dir$prop))
# Model
library("glmmTMB")
install.packages("glmmTMB")
install.packages("glmmTMB")
# Model
library("glmmTMB")
library("stats4")
library("bbmle")
install.packages("TMB", type = "source")
# Model
library("glmmTMB")
library("stats4")
library("bbmle")
install.packages("mvtnorm")
library(emmeans)
install.packages("eemeans")
library(emmeans)
install.packages("emmeans")
library(emmeans)
library(effects)
install.packages("survey")
library(effects)
library(car)
install.packages("car")
Prop_dire<- glmmTMB (prop ~ management + services, family=beta_family(link="logit"), data = Prop_dir) # model that best fit
Anova(Prop_dire)
# Model
library("glmmTMB")
library("stats4")
library("bbmle")
library(emmeans)
library(effects)
library(car)
Prop_dire<- glmmTMB (prop ~ management + services, family=beta_family(link="logit"), data = Prop_dir) # model that best fit
Anova(Prop_dire)
# Summarize the model to view coefficients
summ<-summary(Prop_dire)
# Extract the coefficients (for GLMM it's the average including all the levels)
coefficients <- summ$coefficients$cond
# Extract coefficients for each factor
management_coefs <- coefficients[grep("management", rownames(coefficients)), "Estimate"]
services_coefs <- coefficients[grep("services", rownames(coefficients)), "Estimate"]
# Calculate summary statistics for each factor
management_summary <- mean(management_coefs)
services_summary <- mean(services_coefs)
#Homogeneity
EM<-resid(Prop_dire, type= "response")
FM<-fitted(Prop_dire)
plot(x=FM, y=EM, xlab = "Ajustados", ylab = "Residuales normalizados")
abline(0,0, col="red", lwd= 3)
#independence
E1_lme<-resid(Prop_dire, type= "response")
boxplot(E1_lme ~ management, data = Prop_dir, main = "Management")
# posthoc ()
post_dir<- emmeans(Prop_dire, ~ management)
pairs(post_dir)
post_ser<- emmeans(Prop_dire, ~ services)
pairs(post_ser)
#upload and prepare dataframe
output_ind_ES <- read.csv("Data/Land_use_ind_ES.csv", sep =",")
output_ind_ES$management <- factor(output_ind_ES$management, levels = c("E", "SE", "M", "SI","I","IN")) #change order of factors
Prop_ind<-output_ind_ES %>% group_by(management,services_to) %>%
mutate(tot = n()) %>% ungroup() %>%
group_by(services_to) %>%
mutate(prop = tot/max(tot)) %>%  #prop of indirect effects on ES retained
dplyr::select(management,services_to,tot,prop) %>% unique()
library(tidyverse)
#upload and prepare dataframe
output_ind_ES <- read.csv("Data/Land_use_ind_ES.csv", sep =",")
output_ind_ES$management <- factor(output_ind_ES$management, levels = c("E", "SE", "M", "SI","I","IN")) #change order of factors
Prop_ind<-output_ind_ES %>% group_by(management,services_to) %>%
mutate(tot = n()) %>% ungroup() %>%
group_by(services_to) %>%
mutate(prop = tot/max(tot)) %>%  #prop of indirect effects on ES retained
dplyr::select(management,services_to,tot,prop) %>% unique()
# adjust the extreme values according to the beta conditions
Prop_ind$prop <- ifelse(Prop_ind$prop == 0, 0.000001,
ifelse(Prop_ind$prop == 1, 0.9999999, Prop_ind$prop))
# Model
library("glmmTMB")
library("stats4")
library("bbmle")
Prop_indi<-glmmTMB (prop ~ management + services_to, family=beta_family(link="logit"), data = Prop_ind) #model that best fit
Anova(Prop_indi)
# Summarize the model to view coefficients
summ<-summary(Prop_indi)
# Extract the coefficients (for GLMM tt's the average including all the levels)
coefficients <- summ$coefficients$cond
# Extract coefficients for each factor
management_coefs <- coefficients[grep("management", rownames(coefficients)), "Estimate"]
services_coefs <- coefficients[grep("services_to", rownames(coefficients)), "Estimate"]
# Calculate summary statistics for each factor
management_summary <- mean(management_coefs)
services_summary <- mean(services_coefs)
#Homogeneity
EM<-resid(Prop_indi, type= "response")
FM<-fitted(Prop_indi)
plot(x=FM, y=EM, xlab = "Ajustados", ylab = "Residuales normalizados")
abline(0,0, col="red", lwd= 3)
#independence
E1_lme<-resid(Prop_indi, type= "response")
boxplot(E1_lme ~ management, data = Prop_ind, main = "Management")
## Amount Bird and butterfly watching
extensive_amount_watching<-direct_ES %>% filter(management=="E" &  (services == "Bird watching" | services == "Butterfly watching" )) %>%
select(node_id, services, abun)
# Merging with other management scenarios and calculate ratio of change
dir_amount_watching <- direct_ES %>% filter(services == "Bird watching" | services == "Butterfly watching" ) %>%
left_join(extensive_amount_watching, by = c("node_id", "services"), suffix = c("", "_extensive")) %>%
mutate(ratio_change = abun / abun_extensive) %>% #ratio of change: values higher than 1 indicates increasing in the amount of E(D)S
select(management,node_id,services,ratio_change)
## Amount if the rest ESs
extensive_amount_rest<-direct_ES %>% filter(management=="E" &  !(services == "Bird watching" | services == "Butterfly watching" )) %>%
select(node_id, services, weight)
# Merging with other management scenarios and calculate ratio of change
dir_amount_rest <- direct_ES %>% filter(!(services == "Bird watching" | services == "Butterfly watching" )) %>%
left_join(extensive_amount_rest, by = c("node_id", "services"), suffix = c("", "_extensive")) %>%
mutate(ratio_change = weight / weight_extensive) %>%  #ratio of change: values higher than 1 indicates increasing in the amount of E(D)S
select(management,node_id,services,ratio_change)
## Final amount
dir_amount<- rbind(dir_amount_watching,dir_amount_rest)
# Model
library(glmmTMB)
m_amount<- glmmTMB(ratio_change ~ management+services + (1|node_id),family = Gamma(link = "log"),
data = dir_amount) #the lowest AIC, interaction did not converge
m_amount<- glmmTMB(ratio_change ~ management+services + (1|node_id),family = Gamma(link = "log"),
data = dir_amount) #the lowest AIC, interaction did not converge
Anova(m_amount)
View(dir_amount)
View(dir_amount)
# Model
library(glmmTMB)
m_amount<- glmmTMB(ratio_change ~ management+services + (1|node_id),family = Gamma(link = "log"),
data = dir_amount) #the lowest AIC, interaction did not converge
Anova(m_amount)
# Summarize the model to view coefficients
summ<-summary(m_amount)
# Extract the coefficients (for GLMM It's the average including all the levels)
coefficients <- summ$coefficients$cond
# Extract coefficients for each factor
management_coefs <- coefficients[grep("management", rownames(coefficients)), "Estimate"]
## -- Load libraries --------------------------------------------------------------------------------------------------------
library(emln) # multilayer package
library(readr)
library(ggplot2)
library(tidyverse)
## -- get_data--------------------------------------------------------------------------------------------------------
setwd("/Users/agustin/Desktop/Papers/Norwood_farm/Norwood_Tinio")
## Amount Bird and butterfly watching
extensive_amount_watching<-direct_ES %>% filter(management=="E" &  (services == "Bird watching" | services == "Butterfly watching" )) %>%
select(node_id, services, abun)
#upload and prepare dataframe
direct_ES<- read.csv("Data/Land_use_dir_ES.csv", sep =",")
direct_ES$management <- factor(direct_ES$management, levels = c("E", "SE", "M", "SI","I","IN")) #change order of factors
## Amount Bird and butterfly watching
extensive_amount_watching<-direct_ES %>% filter(management=="E" &  (services == "Bird watching" | services == "Butterfly watching" )) %>%
select(node_id, services, abun)
# Merging with other management scenarios and calculate ratio of change
dir_amount_watching <- direct_ES %>% filter(services == "Bird watching" | services == "Butterfly watching" ) %>%
left_join(extensive_amount_watching, by = c("node_id", "services"), suffix = c("", "_extensive")) %>%
mutate(ratio_change = abun / abun_extensive) %>% #ratio of change: values higher than 1 indicates increasing in the amount of E(D)S
select(management,node_id,services,ratio_change)
## Amount if the rest ESs
extensive_amount_rest<-direct_ES %>% filter(management=="E" &  !(services == "Bird watching" | services == "Butterfly watching" )) %>%
select(node_id, services, weight)
# Merging with other management scenarios and calculate ratio of change
dir_amount_rest <- direct_ES %>% filter(!(services == "Bird watching" | services == "Butterfly watching" )) %>%
left_join(extensive_amount_rest, by = c("node_id", "services"), suffix = c("", "_extensive")) %>%
mutate(ratio_change = weight / weight_extensive) %>%  #ratio of change: values higher than 1 indicates increasing in the amount of E(D)S
select(management,node_id,services,ratio_change)
## Final amount
dir_amount<- rbind(dir_amount_watching,dir_amount_rest)
# Model
library(glmmTMB)
m_amount<- glmmTMB(ratio_change ~ management+services + (1|node_id),family = Gamma(link = "log"),
data = dir_amount) #the lowest AIC, interaction did not converge
m_amount<- glmmTMB(ratio_change ~ management+services,family = Gamma(link = "log"),
data = dir_amount) #the lowest AIC, interaction did not converge
Anova(m_amount)
# Model
library(glmmTMB)
m_amount<- glmmTMB(ratio_change ~ management+services + (1|node_id),family = Gamma(link = "log"),
data = dir_amount) #the lowest AIC, interaction did not converge
#upload and prepare dataframe
direct_ES<- read.csv("Data/Land_use_dir_ES.csv", sep =",")
direct_ES$management <- factor(direct_ES$management, levels = c("E", "SE", "M", "SI","I","IN")) #change order of factors
Prop_dir<-direct_ES %>% group_by(management,services) %>%
mutate(tot = n()) %>% ungroup() %>%
group_by(services) %>%
mutate(prop = tot/max(tot)) %>%  # Prop. of direct ES retained
dplyr::select(management,services,tot,prop) %>%
unique()
# adjust the extreme values according to the beta conditions
Prop_dir$prop <- ifelse(Prop_dir$prop == 0, 0.000001,
ifelse(Prop_dir$prop == 1, 0.9999999, Prop_dir$prop))
# Model
library("glmmTMB")
library("stats4")
library("bbmle")
library(emmeans)
library(effects)
library(car)
Prop_dire<- glmmTMB (prop ~ management + services, family=beta_family(link="logit"), data = Prop_dir) # model that best fit
Anova(Prop_dire)
# Summarize the model to view coefficients
summ<-summary(Prop_dire)
# Extract the coefficients (for GLMM it's the average including all the levels)
coefficients <- summ$coefficients$cond
# Extract coefficients for each factor
management_coefs <- coefficients[grep("management", rownames(coefficients)), "Estimate"]
services_coefs <- coefficients[grep("services", rownames(coefficients)), "Estimate"]
# Calculate summary statistics for each factor
management_summary <- mean(management_coefs)
services_summary <- mean(services_coefs)
#Homogeneity
EM<-resid(Prop_dire, type= "response")
FM<-fitted(Prop_dire)
plot(x=FM, y=EM, xlab = "Ajustados", ylab = "Residuales normalizados")
abline(0,0, col="red", lwd= 3)
#independence
E1_lme<-resid(Prop_dire, type= "response")
boxplot(E1_lme ~ management, data = Prop_dir, main = "Management")
View(Prop_dire)
View(Prop_dir)
# Model
library(glmmTMB)
m_amount<- glmmTMB(ratio_change ~ management+services + (1|node_id),family = Gamma(link = "log"),
data = dir_amount) #the lowest AIC, interaction did not converge
m_amount2<- glmmTMB(ratio_change ~ management+services,family = Gamma(link = "log"),
data = dir_amount) #the lowest AIC, interaction did not converge
m_amount3<- glmmTMB(ratio_change ~ management+services + node_id,family = Gamma(link = "log"),
data = dir_amount) #the lowest AIC, interaction did not converge
Anova(m_amount2_m_amount3)
Anova(m_amount2,m_amount3)
AIC(m_amount2,m_amount3)
Anova(m_amount3)
# Model
library(glmmTMB)
m_amount<- glmmTMB(ratio_change ~ management+services + (1|node_id),family = Gamma(link = "log"),
data = dir_amount) #the lowest AIC, interaction did not converge
summary(dir_amount$ratio_change)
sum(dir_amount$ratio_change <= 0)
m_amount<- glmmTMB(ratio_change ~ management+services + (1|node_id),family = Gamma(link = "log"),
data = dir_amount, control=glmmTMBControl(optimizer=optim, optArgs=list(method="BFGS"))) #the lowest AIC, interaction did not converge
m_amount<- glmmTMB(ratio_change ~ management+services + (1|node_id),family = Gamma(link = "log"),
data = dir_amount, control=glmmTMBControl(optimizer=optim, optArgs=list(method="Nelder-Mead"))) #the lowest AIC, interaction did not converge
m_amount<- glmmTMB(ratio_change ~ management+services + (1|node_id),family = Gamma(link = "log"),
data = dir_amount, control=glmmTMBControl(optimizer=optim, optArgs=list(method="L-BFGS-B"))) #the lowest AIC, interaction did not converge
